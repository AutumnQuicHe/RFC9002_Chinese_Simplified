---
title: "7.7. 限速"
anchor: "7.7_Pacing"
weight: 7700
rank: "h2"
---

发送方{{< req_level SHOULD >}}基于来自拥塞控制器的输入来限制发送在途数据包的速率。

不带间隔地向网络中发送多个数据包的行为将构成一次数据包暴发，这可能引发短暂的拥塞与丢包。发送方**必需**要么使用限速器要么限制这样的暴发。发送方{{< req_level SHOULD >}}将一次暴发的数量限制至不超过初始拥塞窗口的尺寸，详见[第7.2章]()。如果发送方能够了解到通向接收方的网络路径可以吸收较大的暴发，那么它{{< req_level MAY >}}使用更高的上限值。

QUIC实现应该小心地设计其拥塞控制器的架构以使之与限速器协作良好。比如，限速器可以包装拥塞控制器并且控制拥塞窗口的可用性，或者限速器可以限制由拥塞控制器传出的数据包的发送速率。

按时送达**ACK帧**对于高效的丢包检测是非常重要的。因此，为了避免延误，仅包含**ACK帧**的数据包{{< req_level SHOULD >}}不受限速器影响。

终端可以自由实现限速器。完美地进行限速的发送方能将数据包等间隔地发送出去。对于基于窗口的拥塞控制器，例如本文档中描述的这种，该发送速率可以用将拥塞窗口平摊到RTT上的方法来计算。其表示方法如下，其中速率（`rate`）和拥塞窗口（`congestion_window`）都用字节来度量：

{{% block_ref
indx="Pseudocode_7_7_1" %}}

```
rate = N * congestion_window / smoothed_rtt
```

{{% /block_ref %}}

或用每两个数据包间的时间间隔（`interval`）的方式来表示（`packet_size`表示数据包尺寸）：

{{% block_ref
indx="Pseudocode_7_7_2" %}}

```
interval = ( smoothed_rtt * packet_size / congestion_window ) / N
```

{{% /block_ref %}}

使用较小的但至少为`1`的`N`值（例如`1.25`）确保了RTT间的偏差不会导致拥塞窗口的不完全利用。

在实践时要考量的方面，例如分包、调度延迟和计算效率，可能使得发送方在远小于RTT的时间间隔内偏离该速率。

限速器的一种可能实现策略是使用漏桶算法，其中“桶”的容量被限制为最大暴发量，填充“桶”的速率由上文中的函数决定。
