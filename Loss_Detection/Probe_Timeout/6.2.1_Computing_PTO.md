---
title: "6.2.1. 计算PTO"
anchor: "6.2.1_Computing_PTO"
weight: 6210
rank: "h3"
---

当发送ACK触发包时，发送方会启动一个PTO计时器，它的计算方式如下：

{{% block_ref
indx="Pseudocode_6_2_1_1" %}}

```
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
```

{{% /block_ref %}}

PTO就是发送方为某数据包的确认应该等待的时间量。该时间量包含了预估的网络RTT（`smoothed_rtt`）、预估的偏差量（`4*rttvar`）和`max_ack_delay`，包含`max_ack_delay`能将接收方可以在发送确认前延迟的最长时间考虑进来。

当在初始数据包号空间或握手数据包号空间中使用PTO时，其计算式中的`max_ack_delay`要设为`0`，因为对端不应该有意推迟发送这些数据包；详见《[QUIC传输](../RFC9000_Chinese_Simplified)》的[第13.2.1章](../RFC9000_Chinese_Simplified/#13.2.1_Sending_ACK_Frames)。

PTO的值{{< req_level MUST >}}不小于`kGranularity`，以避免计时器立即超时。

当多个数据包号空间中的ACK触发包均在途时，计时器{{< req_level MUST >}}被设置为在初始数据包号空间和握手数据包号空间中较早超时的那个值。

终端在握手确认前{{< req_level MUST_NOT >}}为应用数据数据包号空间设置其PTO计时器。这么做避免了终端在对端还没有用于处理的密钥或终端还没有用于处理确认的密钥时就重传信息。举例来说，这种情况可能在客户端向服务器发送0-RTT数据包时出现；它无需了解服务器是否会有能力解密就会发送它们。类似地，这种情况还可能在服务器未等到确认客户端已验证完服务器证书从而读取1-RTT数据包就发送这些数据包时出现。

发送方{{< req_level SHOULD >}}在每次发送或确认ACK触发包时，或当启用初始密钥或握手密钥时（详见《[QUIC-TLS](../RFC9001_Chinese_Simplified)》的[第4.9章](../RFC9001_Chinese_Simplified/#4.9_Discarding_Unused_Keys)），重启自己的PTO计时器。这确保了计算出来的PTO总是基于最新的RTT预估的，并且针对的总是不同数据包号空间中的那个正确的数据包。

当PTO计时器超时时，{{< req_level MUST >}}增加PTO补偿，使得PTO被设置为当前量的两倍。除非是下文所述的情况，否则PTO补偿因子会在接收到确认时被重置。服务器可能在握手期间花费比其他时候更长的时间来响应数据包。为了保护这样的服务器免于重复的客户端探测包，尚未确定服务器是否已验证完自身地址的客户端处的PTO补偿不会被重置。也就是说，客户端不会在接收到来自初始数据包中的确认的时候重置PTO补偿因子。

发送方速率的指数级降低非常重要，因为严重的拥塞引发的数据包或确认的丢包可能连续导致PTO超时。即使多个数据包号空间中均有在途数据包，所有空间中PTO的指数级增加也能避免对网络施加额外的负载。举个例子，初始数据包号空间中的超时会使得握手数据包号空间中的超时时间翻倍。

连续PTO超时的总时长会受到空闲超时时间的限制。

如果已经为基于发送时间阈值的丢包检测设置了计时器，那么{{< req_level MUST_NOT >}}设置PTO计时器。为基于发送时间阈值的丢包检测设置的计时器在大多数情况下都会比PTO计时器更早超时，并且更不太可能会无效地重传数据。
